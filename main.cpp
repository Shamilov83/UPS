/**
Программа управления бесперебойного источника питания на базе ардуино мини про. 
Производится контроль входного и выходного напряжения, напряжения аккумулятора.
При работе от сети источник питания производит зарядку аккумулятора по мере его разряда,
а также производится тестирование аккумулятора (один раз в трое суток) путем подключения на 1 мин. нагрузочного резистора.
Если напряжение аккумулятора при тесте просело более 2 вольт устанавливается статус о негодности аккумулятора.
При отключении напряжения сети источник питания переходит на работу от аккумулятора и устанавливается соотвествующий флаг. 
Каждые 30 с  производится замер напряжения аккумулятора и на основании этих данных производится расчет остаточного 
времени работы устройства до отключения нагрузки, значение расчета записывается в память. 
 При падении напряжения аккумулятора до порогового уровня, равного 7 вольт,  отключается нагрузка. 
*/

#include "mdef.h"

volatile uint16_t counter_test =0;
/**********************************************************
 * ОБРАБОТКА ПРЕРЫВАНИЙ
 */
ISR(TIMER1_OVF_vect)			//инкремент счетчика периода запуска теста T1. период вызова прерывание при частоте 16Мгц 238мс
{
	TCNT1 = ust_tc1;			//предустановка таймера-счетчика1,  переполнение каждые 8с		
	//counter_test++;				//тестовый счетчик
}
/**********************************************************
 *   Переполнение по таймеру
 * 	 каждую 10 миллисекунду
 *********************************************************/

ISR(TIMER0_OVF_vect)			
{
	TCNT0 = ust_tc0;			//предустановка таймера-счетчика0,  переполнение каждые 1мс
	timer1ms++;					//увеличение внутренних счетчиков
	count_time_zar++;			//счетчик времени заряда
	count_period_test++;		//инкремент счетчика периода запуска теста T1		
	count_time_test_T2++;		//счетчик времени опроса напряжения батареи
	count_time_test++;			//инкремент счетчика длительности теста
	counter_test++;				//тестовый счетчик
}


/**********************************************************
 *  USART, Приём байта завершён
 *********************************************************/ 
ISR(USART_RX_vect)
{
	unsigned char temp;
	timer1ms  = 0;						//обнулить счетчик между байтами
	temp = UDR0;						//напрямую в массив из UDR писать нельзя
	usart_buf[received_bytes] = temp;	//поместить в буфер приёма
	received_bytes++;					//в следующий раз разместить в след.ячейку
	if(received_bytes > SIZE_BUF) 		//если буфер переполнен
	{
		received_bytes = 0;				//то сбросить индекс кол-ва байт в буфере
	}
	
}

	
int main(void)
{
	flagi = 0;
	flag_d = 0;
	flag_z = 0;
	
	
	received_bytes = 0;						// количество принятых байт в массив
	timer1ms=0;								// считает время между байтами
	init_device();							// инициализация контроллера


	while (1) 
	{
		
	_delay_ms(10);
	
		//проверить есть ли данные для приема
		if (received_bytes && (timer1ms >= TIME_BETWEEN_BYTE))
	
		{
			parsing_package();		//обработка посылки						
		} 	
	
		
	#if DEBUG
	if(count_time_zar>1000)
	{
		x="_____________flag_z = ";
		transmit((uint8_t*)x,strlen(x));
		itoa(flag_z,x,10);
		transmit((uint8_t*)x,strlen(x));
		
		x="______________\r\n";
		transmit((uint8_t*)x,strlen(x));
		
		x="_______________Ubat = ";
		transmit((uint8_t*)x,strlen(x));
		
		itoa(read_adc(Ubat),x,10);
		transmit((uint8_t*)x,strlen(x));
		
		x="______________\r\n";
		transmit((uint8_t*)x,strlen(x));
		count_time_zar=0;
	}
	#endif

	
		asm("wdr");		//обнуление сторожевого таймера		 
			//если входное напряжение ниже установки, то 
			//РАБОТА ОТ АКБ 
			if(read_adc(Uin)<UST_Uin)
			//if(0)						
			{				

							OUT_BAT_ON();				//подключить преобразователь к аккумулятору		
							NAGR_ON();					// включить нагрузку		
							SetBit(flagi,5);			//установить флаг включения нагрузки				
							PREOBR_OFF();				// отключить сеть				
							ZAR_OFF();					// отключить зарядку  				
							SetBit(flagi,7);			//установить флаг работы от аккумулятора (бит 7<<1)				
							Flag_test = 0;				//сбросить флаг проведения теста на случай если отключение сети произойдет в момент теста							
							LED_AKK_ON();				// индикация РАБОТЫ ОТ БАТАРЕИ				
							LED_PWR_OFF();				//ОТКЛЮЧИТЬ ИНДИКАТОР РАБОТЫ ОТ СЕТИ
							RAZR_OFF();					//прекратить тест, если запущен
							LED_RAZR_OFF();				//отключить индикатор теста					
							LED_ZAR_OFF();				//отключить индикацию заряда				
							count_period_test = 0;		//обнулить счетчик запуска теста.
								
									if(count_time_test_T2>=Ust_count2)		
									{  																		
										//вычислить и записать время работы
										time_work();
										//обнулить счетчик периода замера напряжения 
										// аккумулятора при автономном режиме
										count_time_test_T2 = 0;																		
									}
			}
			//если выше, то 
			//РАБОТА ОТ СЕТИ
			else
			{	
				Tp = 0xFFFFFFFF;
				LED_AKK_OFF();				//отключить индикацию работы от аккумулятора
				LED_PWR_ON();				//включить индикацию работы от сети
				PREOBR_ON();				//ПОДКЛЮЧИТЬ ПРЕОБРАЗОВАТЕЛЬ К СЕТИ
				NAGR_ON();					//ПОДКЛЮЧИТЬ НАГРУЗКУ
				SetBit(flagi,5);			//установить флаг включения нагрузки
				OUT_BAT_OFF();				//ОТКЛЮЧИТЬ ПРЕОБРАЗОВАТЕЛЬ ОТ АККУМУЛЯТОРА			
				ClrBit(flagi,7);			//при работе от сети сбросить бит 7



						//проверить флаг проведения теста. Если тест не проводиться проверить заряд батареи и необходимость теста
						//иначе вызвать функцию теста, которая проверит длительность теста и установит флаг пригодности аккумулятора
						if(!Flag_test)
						{
							
							//проверить флаг запуска заряда, если запущен проверить прошло ли время заряда
							//если не установлен, то проверить напряжение на батареии 
							
							zaryd();	
						}
						else
						{							
							regim_test();			//функция теста.	
						}
						
						
			}	
					
				//проверка выходного напряжения
				if(read_adc(Uout)<UST_Uout)
				//if(0)	
			{
				ClrBit(flagi,5);				//установить флаг отключения нагрузки
				//ZAR_ON();						//включить цепь заряда
				PREOBR_ON();					//подключить преобразователь
				LED_ERR_ON();					//включить индикацию "АВАРИЯ"
				SetBit(flagi,4);				//установить флаг "АВАРИЯ"
				RAZR_OFF();						//прекратить тест
				LED_RAZR_OFF();
				
				#if DEBUG

				ltoa((long)read_adc(Ubat),x,10);
				x="___________________Uout_OFF";
				transmit((uint8_t*)x,strlen(x));
				x="____________________\r\n";
				transmit((uint8_t*)x,strlen(x));
				#endif
			}
			else
			{
				LED_ERR_OFF();					//выключить индикатор "АВАРИЯ"
				ClrBit(flagi,4);				//снять флаг "АВАРИЯ"	
				NAGR_ON();
											
			}

	}
}